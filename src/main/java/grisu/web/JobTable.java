package grisu.web;

import grisu.backend.hibernate.JobStatDAO;
import grisu.backend.model.job.JobStat;
import grisu.control.JobConstants;
import grisu.jcommons.constants.Constants;
import grisu.jcommons.utils.MemoryUtils;
import grisu.jcommons.utils.WalltimeUtils;

import java.sql.Date;
import java.text.DecimalFormat;
import java.text.SimpleDateFormat;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;

import listeners.CustomValueChangeListener;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.google.common.collect.ArrayListMultimap;
import com.vaadin.annotations.AutoGenerated;
import com.vaadin.data.Item;
import com.vaadin.data.util.BeanItemContainer;
import com.vaadin.data.util.DefaultItemSorter;
import com.vaadin.ui.CustomComponent;
import com.vaadin.ui.Label;
import com.vaadin.ui.Panel;
import com.vaadin.ui.TabSheet;
import com.vaadin.ui.TabSheet.SelectedTabChangeEvent;
import com.vaadin.ui.TabSheet.SelectedTabChangeListener;
import com.vaadin.ui.Table;
import com.vaadin.ui.Table.ColumnGenerator;
import com.vaadin.ui.VerticalLayout;

public class JobTable extends CustomComponent {

	@AutoGenerated
	private Panel mainLayout;
	@AutoGenerated
	private TabSheet tabSheet_1;
	@AutoGenerated
	private VerticalLayout verticalLayout_4;
	@AutoGenerated
	private Table tblJobsInactive;
	@AutoGenerated
	private VerticalLayout verticalLayout_3;
	@AutoGenerated
	private Table tblJobs;
	@AutoGenerated
	private Label lblDn;
	@AutoGenerated
	private Label lblClient;
	@AutoGenerated
	private Label lblTotJobs;
	@AutoGenerated
	private Label lblApps;
	@AutoGenerated
	private Label lblCpu;
	@AutoGenerated
	private Label lblWalltime;
	@AutoGenerated
	private VerticalLayout verticallayout;

	private static Logger log = LoggerFactory.getLogger(Thread.currentThread().getClass());

	private BeanItemContainer<JobStat> jobContainer = new BeanItemContainer<JobStat>(JobStat.class){
			//overriding the method so as to enable sorting on generated columns as well 
			public Collection<?> getSortableContainerPropertyIds() {

				LinkedList<Object> sortableColumns=new LinkedList<Object>();
				sortableColumns.add("jobname");//"jobname","active", "submissionType", "fqan", "submittedJobDescription"
				sortableColumns.add("submissionType");
				sortableColumns.add("fqan");
				sortableColumns.add("submittedJobDescription");
				sortableColumns.add("walltime");
				sortableColumns.add("cpus");
				sortableColumns.add("application");
				sortableColumns.add("submitted");
				sortableColumns.add("queue");
				sortableColumns.add("memory");
				sortableColumns.add("executable");

				return sortableColumns;
			}
	};
	private BeanItemContainer<JobStat> inactiveJobContainer = new BeanItemContainer<JobStat>(JobStat.class){
		//overriding the method so as to enable sorting on generated columns as well
		public Collection<?> getSortableContainerPropertyIds() {

			LinkedList<Object> sortableColumns=new LinkedList<Object>();
			sortableColumns.add("jobname");
			sortableColumns.add("submissionType");
			sortableColumns.add("fqan");
			sortableColumns.add("submittedJobDescription");
			sortableColumns.add("walltime");
			sortableColumns.add("cpus");
			sortableColumns.add("application");
			sortableColumns.add("submitted");
			sortableColumns.add("queue");
			sortableColumns.add("memory");
			sortableColumns.add("executable");

			return sortableColumns;
		}
	};

	/*
	 * The values(generated cells) for a key (object) being stored and retrieved in the order in which
	 * they are being called in the setVisibleColumns method. 
	 * So, if this order changes in future, the storage/retrieval order(indices) should change as well  
	 */
	private ArrayListMultimap<Object, String> genColMap = ArrayListMultimap.create();

	/* Multimap to store the objects itemId in the container as key and
	 * the generated column values as value-list
	 * These will be used when sorting generated columns, since their data is not stored
	 * in the container 
	 */
	private static Map<String, Integer> genColNameMap = new HashMap<String, Integer>();

	private Map<String, String> jobPropertyMap;

	
//static map to map the generated columns with their indices 
//	in the Multimap value list	
	static{
		genColNameMap.put("queue", 0);
		genColNameMap.put("walltime", 1);
		genColNameMap.put("cpus", 2);
		genColNameMap.put("memory", 3);
		genColNameMap.put("submitted", 4);
		genColNameMap.put("executable", 5);
	}
	
	/**
	 * The constructor should first build the main layout, set the
	 * composition root and then do any custom initialization.
	 *
	 * The constructor will not be automatically regenerated by the
	 * visual editor.
	 */
	public JobTable() {

		log.debug("Inside constructor");
		System.out.println("jobtab: Inside constructor"+System.currentTimeMillis());
		buildMainLayout();
		setCompositionRoot(mainLayout);

		// TODO add user code here
		tblJobs.setSelectable(true);
		tblJobs.setColumnReorderingAllowed(true);

		tblJobsInactive.setSelectable(true);
		tblJobsInactive.setColumnReorderingAllowed(true);
		//tblJobsInactive.setPageLength(10);

		verticalLayout_3.setSizeUndefined();
		verticalLayout_4.setSizeUndefined();

		tblJobs.addGeneratedColumn("walltime", new ColumnGenerator() {

			public Object generateCell(Table source, Object itemId, Object columnId) {
				// TODO Auto-generated method stub
				//JobStat job = (JobStat)itemId;
				//Map<String, String> propertyMap = job.getProperties();
				//String wallTimeval = propertyMap.get("walltime");
				String wallTimeval = jobPropertyMap.get("walltime");
				if(genColMap.get(itemId).size()<6)
					genColMap.put(itemId, wallTimeval);
				//System.out.println("walltime:"+propertyMap.get("walltime"));
				return WalltimeUtils.convertSeconds(Integer.parseInt(wallTimeval)*60);
			}
		});

		tblJobs.addGeneratedColumn("cpus", new ColumnGenerator() {

			public Object generateCell(Table source, Object itemId, Object columnId) {
				// TODO Auto-generated method stub
				//JobStat job = (JobStat)itemId;
				//Map<String, String> propertyMap = job.getProperties();
				//String cpuVal = propertyMap.get("cpus");
				String cpuVal = jobPropertyMap.get("cpus");
				if(genColMap.get(itemId).size()<6)
					genColMap.put(itemId, cpuVal);
				//System.out.println("cpus:"+propertyMap.get("cpus"));

				return cpuVal;
			}
		});

		tblJobs.addGeneratedColumn("memory", new ColumnGenerator() {

			public Object generateCell(Table source, Object itemId, Object columnId) {
				// TODO Auto-generated method stub
				//JobStat job = (JobStat)itemId;
				//Map<String, String> propertyMap = job.getProperties();
				//System.out.println("memory:"+propertyMap.get("memory"));
				//String memoryVal = propertyMap.get("memory");
				String memoryVal = jobPropertyMap.get("memory");
				if(genColMap.get(itemId).size()<6)
					genColMap.put(itemId, memoryVal);
				return MemoryUtils.humanReadableByteCount(Long.parseLong(memoryVal), false);
				//return propertyMap.get("memory");
			}
		});

		tblJobs.addGeneratedColumn("submitted", new ColumnGenerator() {

			public Object generateCell(Table source, Object itemId, Object columnId) {
				// TODO Auto-generated method stub
//				JobStat job = (JobStat)itemId;
//				Map<String, String> propertyMap = job.getProperties();
				//System.out.println("submitted:"+propertyMap.get("submissionTime"));
				//String val = propertyMap.get("submissionTime");
				String val = jobPropertyMap.get("submissionTime");
				try{
					Date d = new Date(Long.parseLong(val));
					SimpleDateFormat sdf = new SimpleDateFormat("MM/dd/yyyy HH:mm:ss");
					
					if(genColMap.get(itemId).size()<6)
						genColMap.put(itemId, val);
					return sdf.format(d);
				}catch(NumberFormatException nfe){
					if(genColMap.get(itemId).size()<6)
						genColMap.put(itemId, "");
					return "";
				}
			}
		});

		tblJobs.addGeneratedColumn("executable", new ColumnGenerator() {

			public Object generateCell(Table source, Object itemId, Object columnId) {
				// TODO Auto-generated method stub
				//JobStat job = (JobStat)itemId;
				//Map<String, String> propertyMap = job.getProperties();
				//System.out.println("executable:"+propertyMap.get("executable"));
				//String execVal = propertyMap.get("executable");
				String execVal = jobPropertyMap.get("executable");
				if(genColMap.get(itemId).size()<6)
					genColMap.put(itemId, execVal);
				return execVal;
			}
		});

		tblJobs.addGeneratedColumn("queue", new ColumnGenerator() {

			public Object generateCell(Table source, Object itemId, Object columnId) {
				// TODO Auto-generated method stub
				JobStat job = (JobStat)itemId;
				//Map<String, String> propertyMap = job.getProperties();
				jobPropertyMap = job.getProperties();
				//String qVal=propertyMap.get("queue");
				String qVal=jobPropertyMap.get("queue");
				if(genColMap.get(itemId).size()<6)
					genColMap.put(itemId, qVal);
				//System.out.println("executable:"+propertyMap.get("executable"));
				return qVal;
			}
		});

		tblJobsInactive.addGeneratedColumn("walltime", new ColumnGenerator() {

			public Object generateCell(Table source, Object itemId, Object columnId) {
				// TODO Auto-generated method stub
/*				JobStat job = (JobStat)itemId;
				Map<String, String> propertyMap = job.getProperties();
				//System.out.println("walltime:"+propertyMap.get("walltime"));
				return WalltimeUtils.convertSeconds(Integer.parseInt(propertyMap.get("walltime"))*60);
				*/
				String wallTimeval = jobPropertyMap.get("walltime");
				if(genColMap.get(itemId).size()<6)
					genColMap.put(itemId, wallTimeval);
				//System.out.println("walltime:"+propertyMap.get("walltime"));
				return WalltimeUtils.convertSeconds(Integer.parseInt(wallTimeval)*60);
			}
		});

		tblJobsInactive.addGeneratedColumn("cpus", new ColumnGenerator() {

			public Object generateCell(Table source, Object itemId, Object columnId) {
				// TODO Auto-generated method stub
/*				JobStat job = (JobStat)itemId;
				Map<String, String> propertyMap = job.getProperties();
				//System.out.println("cpus:"+propertyMap.get("cpus"));

				return propertyMap.get("cpus");
*/
				String cpuVal = jobPropertyMap.get("cpus");
				if(genColMap.get(itemId).size()<6)
					genColMap.put(itemId, cpuVal);
				//System.out.println("cpus:"+propertyMap.get("cpus"));

				return cpuVal;
			}
		});

		tblJobsInactive.addGeneratedColumn("memory", new ColumnGenerator() {

			public Object generateCell(Table source, Object itemId, Object columnId) {
				// TODO Auto-generated method stub
/*				JobStat job = (JobStat)itemId;
				Map<String, String> propertyMap = job.getProperties();
				//System.out.println("memory:"+propertyMap.get("memory"));
				return MemoryUtils.humanReadableByteCount(Long.parseLong(propertyMap.get("memory")), false);
				//return propertyMap.get("memory");
*/
				String memoryVal = jobPropertyMap.get("memory");
				if(genColMap.get(itemId).size()<6)
					genColMap.put(itemId, memoryVal);
				return MemoryUtils.humanReadableByteCount(Long.parseLong(memoryVal), false);
			}
		});

		tblJobsInactive.addGeneratedColumn("submitted", new ColumnGenerator() {

			public Object generateCell(Table source, Object itemId, Object columnId) {
				// TODO Auto-generated method stub
/*				JobStat job = (JobStat)itemId;
				Map<String, String> propertyMap = job.getProperties();
				//System.out.println("submitted:"+propertyMap.get("submissionTime"));
				String val = propertyMap.get("submissionTime");
				try{
					Date d = new Date(Long.parseLong(val));
					return d.toString();
				}catch(NumberFormatException nfe){
					return "";
				}
*/
				String val = jobPropertyMap.get("submissionTime");
				try{
					Date d = new Date(Long.parseLong(val));
					SimpleDateFormat sdf = new SimpleDateFormat("MM/dd/yyyy HH:mm:ss");

					if(genColMap.get(itemId).size()<6)
						genColMap.put(itemId, val);
					return sdf.format(d);
				}catch(NumberFormatException nfe){
					if(genColMap.get(itemId).size()<6)
						genColMap.put(itemId, "");
					return "";
				}
			}
		});

		tblJobsInactive.addGeneratedColumn("executable", new ColumnGenerator() {

			public Object generateCell(Table source, Object itemId, Object columnId) {
				// TODO Auto-generated method stub
/*				JobStat job = (JobStat)itemId;
				Map<String, String> propertyMap = job.getProperties();
				//System.out.println("executable:"+propertyMap.get("executable"));
				return propertyMap.get("executable");
*/
				String execVal = jobPropertyMap.get("executable");
				if(genColMap.get(itemId).size()<6)
					genColMap.put(itemId, execVal);
				return execVal;
			}
		});		

		tblJobsInactive.addGeneratedColumn("queue", new ColumnGenerator() {

			public Object generateCell(Table source, Object itemId, Object columnId) {
				// TODO Auto-generated method stub
/*				JobStat job = (JobStat)itemId;
				Map<String, String> propertyMap = job.getProperties();
				//System.out.println("executable:"+propertyMap.get("executable"));
				return propertyMap.get("queue");
				*/
				JobStat job = (JobStat)itemId;
				//Map<String, String> propertyMap = job.getProperties();
				jobPropertyMap = job.getProperties();
				//String qVal=propertyMap.get("queue");
				String qVal=jobPropertyMap.get("queue");
				if(genColMap.get(itemId).size()<6)
					genColMap.put(itemId, qVal);
				//System.out.println("executable:"+propertyMap.get("executable"));
				return qVal;				
			}
		});

		tblJobs.setContainerDataSource(jobContainer);
		tblJobsInactive.setContainerDataSource(inactiveJobContainer);

		tblJobs.setVisibleColumns(new Object [] {"jobname", "queue", "walltime", "cpus", "memory", "submitted", "executable", "fqan", "submissionType", "submittedJobDescription" });
		tblJobs.setColumnHeaders(new String [] {"Job Name", "Queue", "Walltime", "CPUs", "Memory", "Submitted At", "Executable","Group", "Status",  "Application key" });		

		tblJobsInactive.setVisibleColumns(new Object [] {"jobname", "queue", "walltime", "cpus", "memory", "submitted", "executable", "fqan", "submissionType", "submittedJobDescription" });
		tblJobsInactive.setColumnHeaders(new String [] {"Job Name", "Queue", "Walltime", "CPUs", "Memory", "Submitted At", "Executable","Group", "Status",  "Application key" });		

		/*jobContainer.setItemSorter(new DefaultItemSorter(new Comparator<Object>() {
			public int compare(Object obj1, Object obj2) {
				// TODO Auto-generated method stub
				if(obj1 instanceof String)
				{
					return ((String)obj1).toLowerCase().compareTo(((String) obj2).toLowerCase());
				}
				else	
				{
					return ((Integer)obj1-(Integer)obj2);
				}
			}
		}));*/

		jobContainer.setItemSorter(new DefaultItemSorter(){
			public int compare(Object o1, Object o2){
				//if(tblJobs.getSortContainerPropertyId().equals("submitted")){
				String propId = (String)tblJobs.getSortContainerPropertyId();
				if(genColNameMap.containsKey(propId)){
					int index = genColNameMap.get(propId);
					int num1, num2;
					String ele1, ele2;
					try{
						ele1 = genColMap.get(o1).get(index);
						ele2 = genColMap.get(o2).get(index);
						//JobStat j1 = (JobStat)o1;
						try{
							num1=Integer.parseInt(ele1);
							num2 = Integer.parseInt(ele2);
							if(tblJobs.isSortAscending())
								return num1-num2;
							else
								return num2-num1;
						}
						catch(NumberFormatException nfe){
							if(tblJobs.isSortAscending())
								return ele1.compareTo(ele2);
							else
								return ele2.compareTo(ele1);
						}
					}catch(Exception e){ //NullPointerException or IndexOutOfBoundException
						return 0;
					}
				}
				return super.compare(o1, o2);
			}			
		});

		inactiveJobContainer.setItemSorter(new DefaultItemSorter(){
			public int compare(Object o1, Object o2){
				//if(tblJobs.getSortContainerPropertyId().equals("submitted")){
				String propId = (String)tblJobsInactive.getSortContainerPropertyId();
				if(genColNameMap.containsKey(propId)){
					int index = genColNameMap.get(propId);
					int num1, num2;
					String ele1, ele2;
					try{
						ele1 = genColMap.get(o1).get(index);
						ele2 = genColMap.get(o2).get(index);
						//JobStat j1 = (JobStat)o1;
						try{
							num1=Integer.parseInt(ele1);
							num2 = Integer.parseInt(ele2);
							if(tblJobsInactive.isSortAscending())
								return num1-num2;
							else
								return num2-num1;
						}
						catch(NumberFormatException nfe){
							if(tblJobsInactive.isSortAscending())
								return ele1.compareTo(ele2);
							else
								return ele2.compareTo(ele1);
						}
					}catch(Exception e){ //NullPointerException or IndexOutOfBoundException
						return 0;
					}
				}
				return super.compare(o1, o2);
			}
		});		
//		
//		Item item = jobContainer.getItem(0);
//		Collection<?> temp = item.getItemPropertyIds();
/*		
		inactiveJobContainer.setItemSorter(new DefaultItemSorter(new Comparator<Object>() {
			public int compare(Object obj1, Object obj2) {
				if(obj1 instanceof String)
					return ((String)obj1).toLowerCase().compareTo(((String) obj2).toLowerCase());
				else	
					return ((Integer)obj1-(Integer)obj2);
			}
		}));
*/
		log.debug("Exiting constructor");
	}


	public void addListener(final CustomValueChangeListener valueChangeListener) {
		// TODO Auto-generated method stub
		tblJobs.addListener(valueChangeListener);
		tblJobsInactive.addListener(valueChangeListener);
		tabSheet_1.addListener(new SelectedTabChangeListener() {

			public void selectedTabChange(SelectedTabChangeEvent event) {
				// TODO Auto-generated method stub
				valueChangeListener.fireValueChange();
			}
		});
	}

	public void setTable(BeanItemContainer<JobStat> jobStatContainer) {
		// TODO Auto-generated method stub
		tblJobs.setContainerDataSource(jobStatContainer);
	}

	public Object getTableClickVal() {
		// TODO Auto-generated method stub
		return tblJobs.getValue();
	}

	public void populate(final String dn, String active, String running) {
		// TODO Auto-generated method stub
		log.debug("Inside populate");
		System.out.println("\n\n\nInside populate");

		genColMap = ArrayListMultimap.create();
		
		JobStatDAO jsDao = new JobStatDAO();
		final List<JobStat> jobs=jsDao.findJobByDN(dn, true);

		//		BeanItemContainer<JobStat> jobContainer = new BeanItemContainer<JobStat>(JobStat.class);
		//		BeanItemContainer<JobStat> inactiveJobContainer = new BeanItemContainer<JobStat>(JobStat.class);

		jobContainer.removeAllItems();
		inactiveJobContainer.removeAllItems();

		System.out.println("No. of jobs: "+jobs.size() +"\ndn: "+dn);

		for(JobStat job:jobs){
			if(job.isActive())
				jobContainer.addBean(job);
			else
				inactiveJobContainer.addBean(job);
		}

		final Set<String> clientSet = new HashSet<String>();
		final Set<String> appSet = new HashSet<String>();

		Thread jobTableUpdater = new Thread(){
			public void run(){

				try{

					System.out.println("jobtableupdater starts");
					Item tblItem=null;
					String client="";
					String appList ="";
					int cpuCount = 0;
					int jobCount =0;
					int wallTimeCount=0;

//					synchronized (tblJobs) {

						for(Object id:tblJobs.getItemIds())
						{
							try{
								tblItem=tblJobs.getItem(id);
								int status  = (Integer) tblItem.getItemProperty("status").getValue();
								//		synchronized (tblItem) {
								tblItem.getItemProperty("submissionType").setValue(""+JobConstants.translateStatus(status));
								//		}
								Map<String, String> app= (Map)tblItem.getItemProperty("properties").getValue();

								//		synchronized (tblItem) {
								String appName = app.get(Constants.APPLICATIONNAME_KEY);

								tblItem.getItemProperty("submittedJobDescription").setValue(appName);//appplication key
								//		}
								clientSet.add(app.get("client"));
								appSet.add(appName);

								cpuCount=cpuCount+Integer.parseInt(app.get("cpus"));
								wallTimeCount=wallTimeCount+Integer.parseInt(app.get("walltime"));
							}
							catch(Exception e)
							{
								System.out.println("for loop1");
								e.printStackTrace();
							}
						}
//					}
//
//					synchronized (tblJobsInactive) {

						for(Object id:tblJobsInactive.getItemIds())
						{
							try{
								tblItem=tblJobsInactive.getItem(id);
								int status  = (Integer) tblItem.getItemProperty("status").getValue();
								//	synchronized (tblItem) {
								tblItem.getItemProperty("submissionType").setValue(""+JobConstants.translateStatus(status));	
								//	}

								Map<String, String> app= (Map)tblItem.getItemProperty("properties").getValue();

								//	synchronized (tblItem) {
								tblItem.getItemProperty("submittedJobDescription").setValue(app.get(Constants.APPLICATIONNAME_KEY));//appplication key	
								//	}

								clientSet.add(app.get("client"));
								cpuCount=cpuCount+Integer.parseInt(app.get("cpus"));
								wallTimeCount=wallTimeCount+Integer.parseInt(app.get("walltime"));
							}catch(Exception e){
								System.out.println("for loop2");
								e.printStackTrace();
							}
						}
//					}
					for(String cli:clientSet){
						if(cli!=null)
							client+=cli+", ";
					}
					if(client.length()>0){
						lblClient.setVisible(true);
						lblClient.setValue("Client(s): "+client.substring(0, client.length()-2));
					}
					else
					{
						lblClient.setVisible(false);
					}

					for(String app:appSet){
						if(app!=null)
							appList+=app+", ";
					}
					if(appList.length()>0){
						lblApps.setValue("Application(s): "+appList.substring(0, appList.length()-2));
						lblApps.setVisible(true);
					}
					else
						lblApps.setVisible(false);


					JobStatDAO jsDao = new JobStatDAO();
					jobCount = //jsDao.findJobCount(dn);
							jobs.size();
					lblTotJobs.setValue("Total Jobs: "+jobCount +"(Active: "+tblJobs.size()+", Running: "+jsDao.findRunningJobCount(dn)+")");
					
					double cpuAvg = (double)cpuCount/(double)jobCount;
					double wallTimeAvg= (double)wallTimeCount/(double)cpuCount;

					DecimalFormat df = new DecimalFormat("#.##");
					lblCpu.setValue("Average number of CPUs: "+df.format(cpuAvg));
					lblWalltime.setValue("Average Walltime per CPU: "+WalltimeUtils.convertSeconds((int) (wallTimeAvg*60)));

					System.out.println("jobtableupdater ends");
				}
				catch(Exception e){
					System.out.println("exception in jobtableupdater");
					e.printStackTrace();
				}
			}
		};

		tblJobs.select(tblJobs.firstItemId());
		tblJobsInactive.select(tblJobsInactive.firstItemId());
		
		if(tblJobs.size()==0){
			tabSheet_1.setSelectedTab(verticalLayout_4);
		}
		
		if(tblJobsInactive.size()==0){
			tabSheet_1.setSelectedTab(verticalLayout_3);
		}

		fireComponentEvent();

		lblDn.setValue("DN: "+dn);
		jobTableUpdater.start();

		log.debug("Exiting populate");
		System.out.println("jobtab: Exiting populate");
		System.out.println("jobtab: exit populate"+System.currentTimeMillis());
	}

	public Object getSelectedJob() {
		// TODO Auto-generated method stub
		if(tabSheet_1.getSelectedTab().equals(verticalLayout_3))
			return tblJobs.getValue();
		else
			return tblJobsInactive.getValue();
	}

	public void setTitle(String username) {
		// TODO Auto-generated method stub
		mainLayout.setCaption("Jobs for "+username);
	}

	@AutoGenerated
	private Panel buildMainLayout() {
		// common part: create layout
		mainLayout = new Panel();
		mainLayout.setImmediate(false);
		mainLayout.setWidth("100%");
		mainLayout.setHeight("100%");

		// top-level component properties
		setWidth("100.0%");
		setHeight("100.0%");

		verticallayout = buildVerticalLayout();
		mainLayout.setContent(verticallayout);
		return mainLayout;
	}

	@AutoGenerated
	private VerticalLayout buildVerticalLayout()
	{
		verticallayout = new VerticalLayout();
		verticallayout.setImmediate(false);
		verticallayout.setWidth("100%");
		verticallayout.setHeight("100%");
		verticallayout.setSpacing(true);

		// top-level component properties
		setWidth("100.0%");
		setHeight("100.0%");


		// lblTotJobs
		lblTotJobs = new Label();
		lblTotJobs.setImmediate(false);
		lblTotJobs.setWidth("-1px");
		lblTotJobs.setHeight("-1px");
		lblTotJobs.setValue("Total Jobs: ");
		verticallayout.addComponent(lblTotJobs);		

		// lblDn
		lblDn = new Label();
		lblDn.setImmediate(false);
		lblDn.setWidth("-1px");
		lblDn.setHeight("-1px");
		lblDn.setValue("DN: ");
		verticallayout.addComponent(lblDn);

		// lblClient
		lblClient = new Label();
		lblClient.setImmediate(false);
		lblClient.setWidth("-1px");
		lblClient.setHeight("-1px");
		lblClient.setValue("DN: ");
		verticallayout.addComponent(lblClient);

		// lblApps
		lblApps = new Label();
		lblApps.setImmediate(false);
		lblApps.setWidth("-1px");
		lblApps.setHeight("-1px");
		lblApps.setValue("DN: ");
		verticallayout.addComponent(lblApps);

		// lblCpu
		lblCpu = new Label();
		lblCpu.setImmediate(false);
		lblCpu.setWidth("-1px");
		lblCpu.setHeight("-1px");
		lblCpu.setValue("DN: ");
		verticallayout.addComponent(lblCpu);

		// lblWalltime
		lblWalltime = new Label();
		lblWalltime.setImmediate(false);
		lblWalltime.setWidth("-1px");
		lblWalltime.setHeight("-1px");
		lblWalltime.setValue("DN: ");
		verticallayout.addComponent(lblWalltime);		

		// tabSheet_1
		tabSheet_1 = buildTabSheet_1();
		verticallayout.addComponent(tabSheet_1);
		return verticallayout;
	}

	@AutoGenerated
	private TabSheet buildTabSheet_1() {
		// common part: create layout
		tabSheet_1 = new TabSheet();
		tabSheet_1.setImmediate(true);
		tabSheet_1.setWidth("100%");
		tabSheet_1.setHeight("100%");

		// verticalLayout_3
		verticalLayout_3 = buildVerticalLayout_3();
		tabSheet_1.addTab(verticalLayout_3, "Active Jobs", null);

		// verticalLayout_4
		verticalLayout_4 = buildVerticalLayout_4();
		tabSheet_1.addTab(verticalLayout_4, "Inactive Jobs", null);

		return tabSheet_1;
	}

	@AutoGenerated
	private VerticalLayout buildVerticalLayout_3() {
		// common part: create layout
		verticalLayout_3 = new VerticalLayout();
		verticalLayout_3.setImmediate(false);
		verticalLayout_3.setWidth("-1px");
		verticalLayout_3.setHeight("-1px");
		verticalLayout_3.setMargin(false);

		tblJobs = new Table()
		{
			//overriding the method so as to enable sorting on generated columns as well 
			public Collection<?> getSortableContainerPropertyIds() {

				LinkedList<Object> sortableColumns=new LinkedList<Object>();
				sortableColumns.add("jobname");
				sortableColumns.add("submissionType");
				sortableColumns.add("fqan");
				sortableColumns.add("submittedJobDescription");
				sortableColumns.add("walltime");
				sortableColumns.add("cpus");
				sortableColumns.add("application");
				sortableColumns.add("submitted");
				sortableColumns.add("queue");
				sortableColumns.add("memory");
				sortableColumns.add("executable");

				return sortableColumns;
			}
		};

		tblJobs.setImmediate(true);
		tblJobs.setWidth("100.0%");

		verticalLayout_3.addComponent(tblJobs);

		return verticalLayout_3;
	}

	@AutoGenerated
	private VerticalLayout buildVerticalLayout_4() {
		// common part: create layout
		verticalLayout_4 = new VerticalLayout();
		verticalLayout_4.setImmediate(false);
		verticalLayout_4.setWidth("-1px");
		verticalLayout_4.setHeight("-1px");
		verticalLayout_4.setMargin(false);

		// table_1
		tblJobsInactive = new Table(){
			//overriding the method so as to enable sorting only on generated columns as well
			public Collection<?> getSortableContainerPropertyIds() {

				LinkedList<Object> sortableColumns=new LinkedList<Object>();
				sortableColumns.add("jobname");
				sortableColumns.add("submissionType");
				sortableColumns.add("fqan");
				sortableColumns.add("submittedJobDescription");
				sortableColumns.add("walltime");
				sortableColumns.add("cpus");
				sortableColumns.add("application");
				sortableColumns.add("submitted");
				sortableColumns.add("queue");
				sortableColumns.add("memory");
				sortableColumns.add("executable");

				return sortableColumns;
			}
		};
		tblJobsInactive.setImmediate(true);
		tblJobsInactive.setWidth("100.0%");
		tblJobsInactive.setHeight("80.0%");
		verticalLayout_4.addComponent(tblJobsInactive);

		return verticalLayout_4;
	}
}
